import collections
filename = "/home/nicholas/Dropbox/Programming/Advent_of_Code/day6_input.txt"
with open(filename, 'r') as f:
    lines = f.readlines()
coords = [line.split(',') for line in lines]
xcoords = [int(coord[0]) for coord in coords]
ycoords = [int(coord[1]) for coord in coords]
coords = list(zip(xcoords, ycoords))

# Part 1
def manhattan_distance(pt1, pt2):
    """Returns the L1 norm for the vector defined by pt1 and pt2.

    Args:
        pt1: Tuple of two integers
        pt2: Tuple of two integers
    Returns:
        dist: Integer
    """

    return abs(pt2[0]-pt1[0]) + abs(pt2[1]-pt1[1])

# We are looking for largest finite area associated with a point.
# My interpretation of finite is that a point's x and y coordinates
# must be smaller than the maximum values for x and y and larger
# than the minimum values for x and y. This is not sufficient,
# however. The finite area must be inside the box defined by the
# max and min coordinates, since going outside implies an infinte
# area.

xmax = max(xcoords)
ymax = max(ycoords)
xmin = min(xcoords)
ymin = min(ycoords)

xrange = range(xmin, xmax+1) # Want to include end points
yrange = range(ymin, ymax+1)

areas = {point: 0 for point in coords}
distances = collections.defaultdict(dict)
grid = [(x, y)
        for x in xrange
        for y in yrange]

def find_ownership(gridpoint, distances, areas):
    '''Finds who is nearest neighbor to gridpoint and updates area dict.

    Points with multiple neighbors from the coord list will result in no change.
    '''
    d = distances[gridpoint]
    mindist = min(d.values())
    vals = list(d.values())
    if vals.index(mindist) != listRightIndex(vals, mindist):
        return areas
    else:
        # print(min(d.values()))
        point = min(d, key=d.get)
        if gridpoint[0] == xmin or gridpoint[0] == xmax:
            areas[point] = 0
        elif gridpoint[1] == ymin or gridpoint[1] == ymax:
            areas[point] = 0
        else:
            areas[point] += 1
        return areas

def listRightIndex(alist, value):
    """Helper function to find righmost incidence of item in list"""
    return len(alist) - alist[-1::-1].index(value) -1


for thispoint in grid:
    for point in  coords:
        if thispoint == point:
            distances[thispoint][point] = 0
            break
        else:
            distances[thispoint][point] = manhattan_distance(thispoint, point)
            # print(distances)
    areas = find_ownership(thispoint, distances, areas)

print(max(areas.values()))




# def area_for_each(points):
